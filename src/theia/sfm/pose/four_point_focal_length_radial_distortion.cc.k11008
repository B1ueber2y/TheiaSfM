// Copyright (C) 2019 The Regents of the University of California (Regents).
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are
// met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//
//     * Redistributions in binary form must reproduce the above
//       copyright notice, this list of conditions and the following
//       disclaimer in the documentation and/or other materials provided
//       with the distribution.
//
//     * Neither the name of The Regents or University of California nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Please contact the author of this library if you have any questions.
// Author: Chris Sweeney (cmsweeney@cs.ucsb.edu)

// This file was created by Steffen Urban (urbste@googlemail.com) or company address (steffen.urban@zeiss.com)
// December 2018


#include <Eigen/Core>
#include <Eigen/SVD>
#include <Eigen/Dense>
#include <Eigen/Geometry>
#include <Eigen/LU>
#include <Eigen/QR>
#include <Eigen/Cholesky>
#include <Eigen/Eigenvalues>
#include <random>

#include "theia/util/random.h"
#include "theia/sfm/pose/four_point_focal_length_radial_distortion.h"
#include "theia/sfm/pose/four_point_focal_length_radial_distortion_helper.h"

namespace theia
{

double sgn(double val) {
  return (0.0 < val) - (val < 0.0);
}

using Matrix34d = Eigen::Matrix<double, 3, 4>;
using Matrix24d = Eigen::Matrix<double, 2, 4>;
using Eigen::Map;
using Eigen::Vector3d;
using Eigen::Vector4d;

bool FourPointsPoseFocalLengthRadialDistortion(
    const std::vector<Eigen::Vector2d>& feature_vectors,
    const std::vector<Eigen::Vector3d>& world_points,
    std::vector<Eigen::Matrix3d>* rotations,
    std::vector<Eigen::Vector3d>* translations,
    std::vector<double>* radial_distortions,
    std::vector<double>* focal_lengths)
{
    //Eigen::Vector4d d; = feature_vectors.topRows<2>().array().pow(2).colwise().sum();
    Vector4d d;
    Matrix34d world_points_;
    for (int i = 0; i < 4; ++i) {
        d[i] = feature_vectors[i][0]*feature_vectors[i][0] +
               feature_vectors[i][1]*feature_vectors[i][1];
        world_points_.row(i) = world_points[i];
    }

    const Vector3d t0 = world_points_.rowwise().mean();
    Matrix34d t0_mat;
    t0_mat<<t0,t0,t0,t0;
    Eigen::Matrix4d U;
    U.setOnes();
    U.topRows<3>() = world_points_ - t0_mat;

    Eigen::JacobiSVD < Eigen::MatrixXd > svd(U.topRows<3>(), Eigen::ComputeFullV | Eigen::ComputeFullU);
    Eigen::Matrix3d R0 = svd.matrixU();

    if (sgn(R0.determinant()) < 0.0)
        R0.col(0) *= -1;
    R0.transposeInPlace();

    U.topRows<3>() = R0 * U.topRows<3>();
    const double scale = U.topRows<3>().array().pow(2).colwise().sum().sqrt().mean();

    U.topRows<3>() /= scale;

    // rescale image points
    Map<Matrix24d> u(feature_vectors.data());
    double f0 = u.topRows<2>().array().pow(2).colwise().sum().sqrt().mean();
    u.topRows<2>() /= f0;

    double k0 = d.array().mean();
    d /= k0;

    Eigen::Matrix<double, 5, 8> M = Eigen::MatrixXd::Zero(5,8);
    M.row(0).leftCols<4>() = U.col(0);
    M.row(1).rightCols<4>() = U.col(0);
    for (int k = 1; k < 4; ++k)
    {
        M.row(k + 1).leftCols<4>()  = u.row(1).col(k)*U.col(k).transpose();
        M.row(k + 1).rightCols<4>() = -u.row(0).col(k)*U.col(k).transpose();
    }

    Eigen::MatrixXd b = Eigen::MatrixXd::Zero(5,1);
    b.topRows<2>() = u.col(0).topRows<2>();
    Eigen::HouseholderQR<Eigen::MatrixXd> qr;
    qr.compute(M.transpose());

    Eigen::Matrix<double, 8, 8> Q = qr.householderQ();
    Eigen::Matrix<double, 8, 5> R = qr.matrixQR().triangularView<Eigen::Upper>();

    Eigen::Matrix<double, 8, 4> N;
    N.setZero();
    N.leftCols<3>() = Q.rightCols<3>();

    // this random rotation is supposed to make the solver more stable
    static theia::RandomNumberGenerator random_number_gen(42);
    Eigen::Vector3d rot_vec(random_number_gen.RandDouble(-0.5,0.5),
                            random_number_gen.RandDouble(-0.5,0.5),
                            random_number_gen.RandDouble(-0.5,0.5));
    Eigen::AngleAxisd random_rot(rot_vec.norm(), rot_vec);
    N.leftCols<3>() *= random_rot.toRotationMatrix();
    Eigen::Matrix<double, 8, 1> x0 = Q.leftCols<5>()* (R.topRows<5>().transpose().inverse() * b);
    N.rightCols<1>() = x0;


    Eigen::MatrixXd C = Eigen::MatrixXd::Zero(6, 3);
    Eigen::Matrix<double, 3, 4> UN1 = U.rightCols<3>().transpose()*N.topRows<4>();
    Eigen::Matrix<double, 3, 4> UN2 = U.rightCols<3>().transpose()*N.bottomRows<4>();
    Eigen::MatrixXd B = Eigen::MatrixXd::Zero(6, 9);

    B.topLeftCorner<3, 3>() = UN1.leftCols<3>();
    B.bottomLeftCorner<3, 3>() = UN2.leftCols<3>();
    B.topRightCorner<3, 1>() = UN1.rightCols<1>();
    B.bottomRightCorner<3, 1>() = UN2.rightCols<1>();

    B.block<3, 4>(0, 3) = d.bottomRows<3>().transpose().replicate(4, 1).transpose().cwiseProduct(UN1);
    B.block<3, 4>(3, 3) = d.bottomRows<3>().transpose().replicate(4, 1).transpose().cwiseProduct(UN2);

    B.col(7).topRows<3>()    = -u.row(0).rightCols<3>().transpose().cwiseProduct(U.row(2).rightCols<3>().transpose());
    B.col(7).bottomRows<3>() = -u.row(1).rightCols<3>().transpose().cwiseProduct(U.row(2).rightCols<3>().transpose());

    // fill these guys
    Eigen::Matrix3d Utmp;
    Utmp.row(0) = U.row(0).rightCols<3>();
    Utmp.row(1) = U.row(1).rightCols<3>();
    Utmp.row(2) = U.row(3).rightCols<3>();

    Eigen::Matrix3d u1temp;
    u1temp.row(0) = u.row(0).rightCols<3>();
    u1temp.row(1) = u.row(0).rightCols<3>();
    u1temp.row(2) = u.row(0).rightCols<3>();
    Eigen::Matrix3d u2temp;
    u2temp.row(0) = u.row(1).rightCols<3>();
    u2temp.row(1) = u.row(1).rightCols<3>();
    u2temp.row(2) = u.row(1).rightCols<3>();

    C.block<3, 3>(0, 0) = Utmp.transpose().cwiseProduct(u1temp.transpose());
    C.block<3, 3>(3, 0) = Utmp.transpose().cwiseProduct(u2temp.transpose());

    Eigen::MatrixXd D = C.jacobiSvd(Eigen::ComputeThinV | Eigen::ComputeThinU).solve(B);

    Eigen::Map<Eigen::RowVectorXd> N_(N.data(), N.size());
    Eigen::Map<Eigen::RowVectorXd> D_(D.data(), D.size());

    Eigen::Matrix<double, 64, 1> data;
    data(0) = 0.0; // using this to keep matlab indices, just an index offset of 1
    data.block<32, 1>(1, 0) = N_;
    data.block<27, 1>(33, 0) = D_;
    data(60,0) = d(0,0);
    data.bottomRows<3>() = U.topRows<3>().col(0);

    Eigen::Matrix<std::complex<double>, 5, 13> sols;
    FourPointsPoseFocalLengthRadialDistortionSolver(data, sols);
    std::vector<int> valid_sols;

    for (int k = 0; k < 13; ++k)
    {
        if (sols(0, k).imag() < -1e-6 ||
            sols(0, k).imag() > 1e-6)
            continue;
        else
            valid_sols.push_back(k);
    }
    const int nr_valid_sols = valid_sols.size();

    Eigen::MatrixXd sols0 = Eigen::MatrixXd::Zero(5, nr_valid_sols);

    for (int k = 0; k < nr_valid_sols; ++k)
        sols0.col(k) = sols.col(valid_sols[k]).real();
    rotations->resize(nr_valid_sols);
    translations->resize(nr_valid_sols);
    radial_distortions->resize(nr_valid_sols);
    focal_lengths->resize(nr_valid_sols);

    for (int i = 0; i < nr_valid_sols; ++i)
    {
        Eigen::Vector3d alpha = sols0.topRows<3>().col(i);
        double k = sols0(3, i);
        double P33 = sols0(4, i);
        Eigen::Vector4d alpha1;
        alpha1.topRows<3>() = alpha;
        alpha1(3) = 1.0;
        Eigen::VectorXd P12_ = N*alpha1;
        Eigen::Map<Eigen::MatrixXd> P12(P12_.data(), 4, 2);

        Eigen::VectorXd tmp = Eigen::VectorXd::Zero(9);
        tmp.topRows<3>() = alpha;
        tmp(3) = k*alpha(0);
        tmp(4) = k*alpha(1);
        tmp(5) = k*alpha(2);
        tmp(6) = k;
        tmp(7) = P33;
        tmp(8) = 1.0;

        Eigen::Vector3d P3_124 = D * tmp;

        Eigen::Vector4d P3;
        P3(0) = P3_124(0);
        P3(1) = P3_124(1);
        P3(2) = P33;
        P3(3) = P3_124(2);

        Eigen::Matrix<double, 3, 4> P;
        P.topRows<2>()    = P12.transpose();
        P.bottomRows<1>() = P3;
        P /= P.bottomRows<1>().leftCols<3>().norm();
        double f = P.topRows<1>().leftCols<3>().norm();
        Eigen::Matrix3d K = Eigen::Matrix3d::Identity();
        K(0, 0) = 1./f;
        K(1, 1) = 1./f;

        (*focal_lengths)[i] = f * f0;
        (*radial_distortions)[i] = k / k0;

        Eigen::MatrixXd Rt = K * P;

        if (Rt.topLeftCorner<3, 3>().determinant() < 0.0)
            Rt *= -1.0;

        // scale radial distortion
        //radial_distortions[i] *= (focal_lengths[i]*focal_lengths[i]);

        Rt.col(3) = Rt.col(3)*scale - Rt.topLeftCorner<3, 3>()*R0*t0;
        Rt.topLeftCorner<3, 3>() = Rt.topLeftCorner<3, 3>() * R0;

        (*rotations)[i] = Rt.topLeftCorner<3, 3>();
        (*translations)[i] = Rt.col(3);
    }

    return nr_valid_sols > 0;
}


}
